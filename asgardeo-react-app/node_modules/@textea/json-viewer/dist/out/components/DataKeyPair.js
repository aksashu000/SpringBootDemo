"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DataKeyPair = void 0;
var jsx_runtime_1 = require("@emotion/react/jsx-runtime");
var material_1 = require("@mui/material");
var react_1 = require("react");
var useColor_1 = require("../hooks/useColor");
var useCopyToClipboard_1 = require("../hooks/useCopyToClipboard");
var useInspect_1 = require("../hooks/useInspect");
var JsonViewerStore_1 = require("../stores/JsonViewerStore");
var typeRegistry_1 = require("../stores/typeRegistry");
var utils_1 = require("../utils");
var Icons_1 = require("./Icons");
var DataBox_1 = require("./mui/DataBox");
var IconBox = function (props) { return ((0, jsx_runtime_1.jsx)(material_1.Box, __assign({ component: 'span' }, props, { sx: __assign({ cursor: 'pointer', paddingLeft: '0.7rem' }, props.sx) }))); };
var DataKeyPair = function (props) {
    var _a;
    var value = props.value, prevValue = props.prevValue, path = props.path, nestedIndex = props.nestedIndex;
    var propsEditable = (_a = props.editable) !== null && _a !== void 0 ? _a : undefined;
    var storeEditable = (0, JsonViewerStore_1.useJsonViewerStore)(function (store) { return store.editable; });
    var editable = (0, react_1.useMemo)(function () {
        if (storeEditable === false) {
            return false;
        }
        if (propsEditable === false) {
            // props.editable is false which means we cannot provide the suitable way to edit it
            return false;
        }
        if (typeof storeEditable === 'function') {
            return !!storeEditable(path, value);
        }
        return storeEditable;
    }, [path, propsEditable, storeEditable, value]);
    var _b = (0, react_1.useState)(typeof value === 'function' ? function () { return value; } : value), tempValue = _b[0], setTempValue = _b[1];
    var depth = path.length;
    var key = path[depth - 1];
    var hoverPath = (0, JsonViewerStore_1.useJsonViewerStore)(function (store) { return store.hoverPath; });
    var isHover = (0, react_1.useMemo)(function () {
        return hoverPath && path.every(function (value, index) { return value === hoverPath.path[index] && nestedIndex ===
            hoverPath.nestedIndex; });
    }, [hoverPath, path, nestedIndex]);
    var setHover = (0, JsonViewerStore_1.useJsonViewerStore)(function (store) { return store.setHover; });
    var root = (0, JsonViewerStore_1.useJsonViewerStore)(function (store) { return store.value; });
    var _c = (0, useInspect_1.useInspect)(path, value, nestedIndex), inspect = _c[0], setInspect = _c[1];
    var _d = (0, react_1.useState)(false), editing = _d[0], setEditing = _d[1];
    var onChange = (0, JsonViewerStore_1.useJsonViewerStore)(function (store) { return store.onChange; });
    var keyColor = (0, useColor_1.useTextColor)();
    var numberKeyColor = (0, JsonViewerStore_1.useJsonViewerStore)(function (store) { return store.colorspace.base0C; });
    var highlightColor = (0, JsonViewerStore_1.useJsonViewerStore)(function (store) { return store.colorspace.base0A; });
    var _e = (0, typeRegistry_1.useTypeComponents)(value, path), Component = _e.Component, PreComponent = _e.PreComponent, PostComponent = _e.PostComponent, Editor = _e.Editor;
    var quotesOnKeys = (0, JsonViewerStore_1.useJsonViewerStore)(function (store) { return store.quotesOnKeys; });
    var rootName = (0, JsonViewerStore_1.useJsonViewerStore)(function (store) { return store.rootName; });
    var isRoot = root === value;
    var isNumberKey = Number.isInteger(Number(key));
    var enableClipboard = (0, JsonViewerStore_1.useJsonViewerStore)(function (store) { return store.enableClipboard; });
    var _f = (0, useCopyToClipboard_1.useClipboard)(), copy = _f.copy, copied = _f.copied;
    var highlightUpdates = (0, JsonViewerStore_1.useJsonViewerStore)(function (store) { return store.highlightUpdates; });
    var isHighlight = (0, react_1.useMemo)(function () {
        if (!highlightUpdates || prevValue === undefined)
            return false;
        // highlight if value type changed
        if (typeof value !== typeof prevValue) {
            return true;
        }
        if (typeof value === 'number') {
            // notice: NaN !== NaN
            if (isNaN(value) && isNaN(prevValue))
                return false;
            return value !== prevValue;
        }
        // highlight if isArray changed
        if (Array.isArray(value) !== Array.isArray(prevValue)) {
            return true;
        }
        // not highlight object/function
        // deep compare they will be slow
        if (typeof value === 'object' || typeof value === 'function') {
            return false;
        }
        // highlight if not equal
        if (value !== prevValue) {
            return true;
        }
        return false;
    }, [highlightUpdates, prevValue, value]);
    var highlightContainer = (0, react_1.useRef)();
    (0, react_1.useEffect)(function () {
        if (highlightContainer.current && isHighlight && 'animate' in highlightContainer.current) {
            highlightContainer.current.animate([
                { backgroundColor: highlightColor },
                { backgroundColor: '' }
            ], {
                duration: 1000,
                easing: 'ease-in'
            });
        }
    }, [highlightColor, isHighlight, prevValue, value]);
    var actionIcons = (0, react_1.useMemo)(function () {
        if (editing) {
            return ((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [(0, jsx_runtime_1.jsx)(IconBox, { children: (0, jsx_runtime_1.jsx)(Icons_1.CloseIcon, { sx: { fontSize: '.8rem' }, onClick: function () {
                                // abort editing
                                setEditing(false);
                                setTempValue(value);
                            } }) }), (0, jsx_runtime_1.jsx)(IconBox, { children: (0, jsx_runtime_1.jsx)(Icons_1.CheckIcon, { sx: { fontSize: '.8rem' }, onClick: function () {
                                // finish editing, save data
                                setEditing(false);
                                onChange(path, value, tempValue);
                            } }) })] }));
        }
        return ((0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: [enableClipboard && ((0, jsx_runtime_1.jsx)(IconBox, __assign({ onClick: function (event) {
                        event.preventDefault();
                        try {
                            copy(path, value, utils_1.copyString);
                        }
                        catch (e) {
                            // in some case, this will throw error
                            // fixme: `useAlert` hook
                            console.error(e);
                        }
                    } }, { children: copied
                        ? (0, jsx_runtime_1.jsx)(Icons_1.CheckIcon, { sx: { fontSize: '.8rem' } })
                        : (0, jsx_runtime_1.jsx)(Icons_1.ContentCopyIcon, { sx: { fontSize: '.8rem' } }) }))), (Editor && editable) &&
                    ((0, jsx_runtime_1.jsx)(IconBox, __assign({ onClick: function (event) {
                            event.preventDefault();
                            setEditing(true);
                            setTempValue(value);
                        } }, { children: (0, jsx_runtime_1.jsx)(Icons_1.EditIcon, { sx: { fontSize: '.8rem' } }) })))] }));
    }, [
        Editor,
        copied,
        copy,
        editable,
        editing,
        enableClipboard,
        onChange,
        path,
        tempValue,
        value
    ]);
    var isEmptyValue = (0, react_1.useMemo)(function () { return (0, utils_1.getValueSize)(value) === 0; }, [value]);
    var expandable = !isEmptyValue && !!(PreComponent && PostComponent);
    var KeyRenderer = (0, JsonViewerStore_1.useJsonViewerStore)(function (store) { return store.keyRenderer; });
    var downstreamProps = (0, react_1.useMemo)(function () { return ({
        path: path,
        inspect: inspect,
        setInspect: setInspect,
        value: value,
        prevValue: prevValue
    }); }, [inspect, path, setInspect, value, prevValue]);
    return ((0, jsx_runtime_1.jsxs)(material_1.Box, __assign({ className: 'data-key-pair', "data-testid": 'data-key-pair' + path.join('.'), sx: { userSelect: 'text' }, onMouseEnter: (0, react_1.useCallback)(function () { return setHover(path, nestedIndex); }, [setHover, path, nestedIndex]) }, { children: [(0, jsx_runtime_1.jsxs)(DataBox_1.DataBox, __assign({ component: 'span', className: 'data-key', sx: {
                    lineHeight: 1.5,
                    color: keyColor,
                    letterSpacing: 0.5,
                    opacity: 0.8
                }, onClick: (0, react_1.useCallback)(function (event) {
                    if (event.isDefaultPrevented()) {
                        return;
                    }
                    if (!isEmptyValue) {
                        setInspect(function (state) { return !state; });
                    }
                }, [isEmptyValue, setInspect]) }, { children: [expandable
                        ? (inspect
                            ? ((0, jsx_runtime_1.jsx)(Icons_1.ExpandMoreIcon, { sx: {
                                    fontSize: '.8rem',
                                    '&:hover': { cursor: 'pointer' }
                                } }))
                            : ((0, jsx_runtime_1.jsx)(Icons_1.ChevronRightIcon, { sx: {
                                    fontSize: '.8rem',
                                    '&:hover': { cursor: 'pointer' }
                                } })))
                        : null, (0, jsx_runtime_1.jsx)(material_1.Box, __assign({ ref: highlightContainer, component: 'span' }, { children: (isRoot
                            ? rootName !== false
                                ? (quotesOnKeys ? (0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: ["\"", rootName, "\""] }) : (0, jsx_runtime_1.jsx)(jsx_runtime_1.Fragment, { children: rootName }))
                                : null
                            : KeyRenderer.when(downstreamProps)
                                ? (0, jsx_runtime_1.jsx)(KeyRenderer, __assign({}, downstreamProps))
                                : nestedIndex === undefined && (isNumberKey
                                    ? (0, jsx_runtime_1.jsx)(material_1.Box, __assign({ component: 'span', style: { color: numberKeyColor } }, { children: key }))
                                    : quotesOnKeys ? (0, jsx_runtime_1.jsxs)(jsx_runtime_1.Fragment, { children: ["\"", key, "\""] }) : (0, jsx_runtime_1.jsx)(jsx_runtime_1.Fragment, { children: key }))) })), (isRoot
                        ? (rootName !== false && (0, jsx_runtime_1.jsx)(DataBox_1.DataBox, __assign({ sx: { mr: 0.5 } }, { children: ":" })))
                        : nestedIndex === undefined && ((0, jsx_runtime_1.jsx)(DataBox_1.DataBox, __assign({ sx: { mr: 0.5 } }, { children: ":" })))), PreComponent && (0, jsx_runtime_1.jsx)(PreComponent, __assign({}, downstreamProps)), (isHover && expandable && inspect) && actionIcons] })), (editing && editable)
                ? (Editor && (0, jsx_runtime_1.jsx)(Editor, { value: tempValue, setValue: setTempValue }))
                : (Component)
                    ? (0, jsx_runtime_1.jsx)(Component, __assign({}, downstreamProps))
                    : ((0, jsx_runtime_1.jsx)(material_1.Box, __assign({ component: 'span', className: 'data-value-fallback' }, { children: "fallback: ".concat(value) }))), PostComponent && (0, jsx_runtime_1.jsx)(PostComponent, __assign({}, downstreamProps)), (isHover && expandable && !inspect) && actionIcons, (isHover && !expandable) && actionIcons] })));
};
exports.DataKeyPair = DataKeyPair;
